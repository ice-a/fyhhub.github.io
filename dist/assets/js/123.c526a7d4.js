(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{523:function(t,e,a){"use strict";a.r(e);var r=a(11),i=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"说一下vue3做了哪些优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说一下vue3做了哪些优化"}},[t._v("#")]),t._v(" 说一下vue3做了哪些优化")]),t._v(" "),a("h2",{attrs:{id:"源码优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码优化"}},[t._v("#")]),t._v(" 源码优化")]),t._v(" "),a("ol",[a("li",[t._v("更好的代码管理方式：monorepo")]),t._v(" "),a("li",[t._v("有类型的 JavaScript：TypeScript")])]),t._v(" "),a("h2",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),a("ol",[a("li",[t._v("源码体积优化")])]),t._v(" "),a("ul",[a("li",[t._v("移除一些冷门的 feature（比如 filter、inline-template 等）")]),t._v(" "),a("li",[t._v("引入 tree-shaking 的技术，减少打包体积")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[t._v("数据劫持优化\nVue2中对一个深层的对象会递归 Object.defineProperty 把每一层对象数据都变成响应式的， 而在Vue 3.0只有在触发getter时才会递归处理成响应式")])]),t._v(" "),a("li",[a("p",[t._v("编译优化\n通过编译阶段对静态模板的分析，编译生成了 "),a("code",[t._v("Block tree")]),t._v("。"),a("code",[t._v("Block tree")]),t._v(" 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关，这是一个非常大的性能突破")])]),t._v(" "),a("li",[a("p",[t._v("v-memo\n优化渲染，只有当它依赖的值发生改变，才会重新创建VNode，以及重新渲染子节点， 否则整个VNode的创建和更新都会被跳过")])]),t._v(" "),a("li",[a("p",[t._v("除此之外，Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法")])])]),t._v(" "),a("h2",{attrs:{id:"语法-api-优化-composition-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法-api-优化-composition-api"}},[t._v("#")]),t._v(" 语法 API 优化：Composition API")])])}),[],!1,null,null,null);e.default=i.exports}}]);