# 使用最小花费爬楼梯
数组的每个下标作为一个阶梯，第 `i` 个阶梯对应着一个非负数的体力花费值 `cost[i]`（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

**示例1：**
```
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
```

**示例2：**
```
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
```

## 思路
转移方程：dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]

## 题解
:::: tabs
::: tab 解法1
```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
  const dp = []
  dp[0] = dp[1] = 0
  for (let i = 2;i <= cost.length;i++) {
    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
  }
  return dp[cost.length]
};
```
:::

::: tab 解法2
```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
  const dp = []
  dp[0] = cost[0]
  dp[1] = cost[1];
  for (let i = 2;i < cost.length;i++) {
    // 当前台阶的花费 = （前一阶台阶最小花费，前二个台阶最小花费） + 当前台阶要花费的体力
    dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]
  }
  return Math.min(dp[dp.length - 1], dp[dp.length - 2])
};
```
:::

::: tab 解法3
```js {10}
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
  const m = []
  function func(i) {
    if (i === 0 || i === 1) return 0 
    if (!m[i]) {
      m[i] = Math.min(func(i - 1) + cost[i - 1], func(i - 2) + cost[i - 2])
    }
    return m[i]
  }
  return func(cost.length)
};
```
:::
::::

::: tip
来源：力扣（LeetCode）</br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
:::