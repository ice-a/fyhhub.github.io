(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{519:function(t,e,i){"use strict";i.r(e);var r=i(11),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"说一下nexttick如何实现的"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#说一下nexttick如何实现的"}},[t._v("#")]),t._v(" 说一下nextTick如何实现的")]),t._v(" "),i("h2",{attrs:{id:"核心答案"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#核心答案"}},[t._v("#")]),t._v(" 核心答案")]),t._v(" "),i("p",[t._v("nextTick利用了浏览器事件循环机制，vue为了避免频繁的操作DOM,采用异步的方式更新DOM。这些异步操作会通过nextTick函数将这些操作以cb的形式放到任务队列中（以微任务优先），当每次tick结束之后就会去执行这些cb，更新DOM。")]),t._v(" "),i("p",[t._v("宏任务script - 微任务 - dom渲染 - web Worker - 宏任务")]),t._v(" "),i("p",[t._v("例如更新num++ 执行一千次，不可能每次都更新一次dom,会有非常大的性能损耗，那么可以把更新放到最后一次来做，将更新任务放到异步队列, 做到批量更新")]),t._v(" "),i("p",[t._v("nextTick会根据浏览器兼容性，依次降级使用不同方案")]),t._v(" "),i("ul",[i("li",[t._v("Promise")]),t._v(" "),i("li",[t._v("MutationObserver")]),t._v(" "),i("li",[t._v("setImmediate")]),t._v(" "),i("li",[t._v("setTimeout")])])])}),[],!1,null,null,null);e.default=s.exports}}]);