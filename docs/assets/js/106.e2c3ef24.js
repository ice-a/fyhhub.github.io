(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{507:function(t,e,r){"use strict";r.r(e);var a=r(11),c=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"react-ssr如何保证在客户端渲染一次"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-ssr如何保证在客户端渲染一次"}},[t._v("#")]),t._v(" React SSR如何保证在客户端渲染一次")]),t._v(" "),r("p",[t._v("在react 16前该方法生成的html内容的每一个DOM节点都有一个"),r("code",[t._v("data-react-id")]),t._v("属性，根节点会有一个"),r("code",[t._v("data-react-checksum")]),t._v("属性。\n组件在服务端渲染后，在浏览器端还会渲染一次，来完成组件的交互等逻辑。渲染时，react在浏览器端会计算出组件的"),r("code",[t._v("data-react-checksum")]),t._v("属性值，如果发现和服务端计算的值一致，则不会进行客户端渲染。所以"),r("code",[t._v("data-react-checksum")]),t._v("属性的作用是为了完成组件的双端对比。")]),t._v(" "),r("p",[t._v("如果两个组件的props和DOM结构是相同的，那么计算出的该属性值就是一致的。")]),t._v(" "),r("p",[t._v("也可以换个角度来理解，当双端渲染的组件的props和DOM结构一致时，那么该组件只会渲染一次，客户端会采用服务端渲染的结果，仅作事件绑定等处理，这会让我们的应用有一个非常高效的初次加载体验。")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://react.docschina.org/docs/react-dom.html#hydrate",target:"_blank",rel:"noopener noreferrer"}},[t._v("hydrate"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=c.exports}}]);