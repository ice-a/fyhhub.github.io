(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{440:function(e,t,v){"use strict";v.r(t);var _=v(5),s=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"事件循环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[e._v("#")]),e._v(" 事件循环")]),e._v(" "),v("h2",{attrs:{id:"宏任务和微任务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[e._v("#")]),e._v(" 宏任务和微任务")]),e._v(" "),v("p",[v("strong",[e._v("宏任务")])]),e._v(" "),v("ul",[v("li",[e._v("script(整体代码)")]),e._v(" "),v("li",[e._v("setTimeout")]),e._v(" "),v("li",[e._v("setInterval")]),e._v(" "),v("li",[e._v("setImmediate")]),e._v(" "),v("li",[e._v("MessageChannel")]),e._v(" "),v("li",[e._v("I/O")])]),e._v(" "),v("p",[v("strong",[e._v("微任务")])]),e._v(" "),v("ul",[v("li",[e._v("process.nextTick")]),e._v(" "),v("li",[e._v("Promise")]),e._v(" "),v("li",[e._v("Async/Await(实际就是promise)")]),e._v(" "),v("li",[e._v("MutationObserver")])]),e._v(" "),v("h2",{attrs:{id:"浏览器事件循环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器事件循环"}},[e._v("#")]),e._v(" 浏览器事件循环")]),e._v(" "),v("p",[e._v("总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。")]),e._v(" "),v("h2",{attrs:{id:"node事件循环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node事件循环"}},[e._v("#")]),e._v(" Node事件循环")]),e._v(" "),v("p",[e._v("node 的事件循环的阶段顺序为：\n输入数据阶段(incoming data)->轮询阶段(poll)->检查阶段(check)->关闭事件回调阶段(close callback)->定时器检测阶段(timers)->I/O事件回调阶段(I/O callbacks)->闲置阶段(idle, prepare)->轮询阶段...")]),e._v(" "),v("p",[e._v("阶段概述")]),e._v(" "),v("ul",[v("li",[e._v("定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。")]),e._v(" "),v("li",[e._v("I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。")]),e._v(" "),v("li",[e._v("闲置阶段(idle, prepare)：仅系统内部使用。")]),e._v(" "),v("li",[e._v("轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况   node 将在适当的时候在此阻塞。")]),e._v(" "),v("li",[e._v("检查阶段(check)：setImmediate() 回调函数在这里执行")]),e._v(" "),v("li",[e._v("关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)。")])]),e._v(" "),v("h3",{attrs:{id:"poll阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#poll阶段"}},[e._v("#")]),e._v(" poll阶段")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/1709951e65ffe00e~tplv-t2oaga2asx-watermark.awebp",alt:"poll阶段"}})]),e._v(" "),v("ul",[v("li",[v("p",[e._v("如果当前"),v("code",[e._v("已经存在定时器")]),e._v("，而且有"),v("code",[e._v("定时器到时间了")]),e._v("，拿出来执行，eventLoop 将回到 "),v("code",[e._v("timers 阶段")]),e._v("。")])]),e._v(" "),v("li",[v("p",[e._v("如果"),v("code",[e._v("没有定时器")]),e._v(", 会去看"),v("code",[e._v("回调函数队列")]),e._v("。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制")])]),e._v(" "),v("li",[v("p",[e._v("如果 poll 队列为空时，会有两件事发生")]),e._v(" "),v("ul",[v("li",[e._v("如果有 "),v("code",[e._v("setImmediate")]),e._v(" 回调需要执行，poll 阶段会停止并且进入到 "),v("code",[e._v("check 阶段")]),e._v("执行回调")]),e._v(" "),v("li",[e._v("如果没有 "),v("code",[e._v("setImmediate")]),e._v(" 回调需要执行，会"),v("code",[e._v("等待回调被加入到队列中")]),e._v("并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,"),v("code",[e._v("一段时间后自动进入 check 阶段")]),e._v("。")])])])])])]),e._v(" "),v("h3",{attrs:{id:"check"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#check"}},[e._v("#")]),e._v(" check")]),e._v(" "),v("p",[e._v("check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。")]),e._v(" "),v("h3",{attrs:{id:"process-nexttick"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#process-nexttick"}},[e._v("#")]),e._v(" process.nextTick")]),e._v(" "),v("p",[e._v("process.nextTick 是一个独立于 eventLoop 的任务队列。\n在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("在 node11 之前，因为每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行")])]),e._v(" "),v("li",[v("p",[e._v("在 node11 之后，process.nextTick 是微任务的一种,是先进入 check 阶段，执行一个 setImmediate 宏任务，然后执行其微任务队列，再执行下一个宏任务及其微任务")])])]),e._v(" "),v("p",[v("strong",[e._v("node11 之后一些特性已经向浏览器看齐了，总的变化一句话来说就是，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行对应的微任务队列")])]),e._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6844904079353708557#heading-0",target:"_blank",rel:"noopener noreferrer"}},[e._v("面试题：说说事件循环机制(满分答案来了)"),v("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);